Fullmodel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = Fullmodel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modelm <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modelm = rep(rowSums(EX)-1,3))
return(results)
}
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
source("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX/code/Simulations/LM/shell_script_generator.R")
library(pscl)
library(tidyverse)
library(doParallel)
# library(survival)
# 1. Global Parameters  ----------------------------------------------------------
ncores <- 50
nsample <- 1000
set.seed(2023)
seed_i <- sample(1000000,1000)
source("code/utility.R")
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- LavgM( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- LavgM( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
betatrue <- c(1, -0.5, 0.5)
var1 <- 1
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- LavgM( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- LavgM( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- lm( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- lm( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, colMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
ncores <- 50
nsample <- 1000
set.seed(2023)
seed_i <- sample(1000000,1000)
source("code/utility.R")
setwd("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX")
ncores <- 50
nsample <- 1000
set.seed(2023)
seed_i <- sample(1000000,1000)
source("code/utility.R")
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
result.
result
source("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX/code/Simulations/LM/shell_script_generator.R")
