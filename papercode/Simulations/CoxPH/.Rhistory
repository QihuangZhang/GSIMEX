knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
betatrue <- c(1, -0.5, 0.5)
var1 <- 1
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- LavgM( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- LavgM( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- lm( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, coLavgMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
library(pscl)
library(tidyverse)
# library(survival)
set.seed(2023)
seed_i <- sample(1000000, 1000)
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
Sim_LavgM_CV_MEonly <- function(SIM_id, beta, Mis_mtr, sd_error, maxq = 6, zeta_m = 2, B = 400, M = 30,  nfold = 20, CVstep = 10, CVmfold = 3){
# Data Generation
set.seed(SIM_id)
Covarmain1 <- data.frame(1, X1 = runif(nsample,-3,4), X2 = rbinom(nsample,1,0.5))
mu <- as.matrix(Covarmain1) %*% t(t(beta))
epsilon <- rnorm(nsample, 0, 1)
Y <- mu + epsilon
SimData <- data.frame(Covarmain1, Y)
# Oracle method
coef_orc <- lm( Y ~ X1 + X2,data = SimData)$coef
# Adding Mismesurement to Correct Data
SimData$X1star <- SimData$X1 + rnorm(nsample, mean = 0, sd = sd_error)
# SimData$X2star <- MCoperator(Mis_mtr, zeta = 1, SimData$X2)
coefs_Z <- NULL
for (i in 1:B){
coefs_Z_i <- NULL
for (j in 1:M) {
epsilon <- i/B*zeta_m
SimData$W1 <- SimData$X1star + rnorm(nsample, mean = 0, sd = epsilon)
# SimData$W2 <- MCoperator(Mis_mtr, zeta = epsilon, SimData$X2star)
model_ME <- lm( Y ~ W1 + X2, data = SimData)
coefs_Z_i <- rbind(coefs_Z_i, c(epsilon, unlist(model_ME$coefficients)))
}
coefs_Z <- rbind(coefs_Z, colMeans(coefs_Z_i))
}
# Extrapolation
q <- maxq
l <- rep(list(0:1),q)
EX <- expand.grid(l, KEEP.OUT.ATTRS =  F)
FulLavgModel_index <- 2^c(0:q)
modelorder <- cut(1:2^q,breaks = FulLavgModel_index, labels = 0:(q-1), include.lowest = FALSE, right = F)
modelorder <- factor(modelorder, levels = c(0:q), labels = 0:q)
modelorder[length(modelorder)] <- q
# modeLavgM <- rep(rowSums(EX)-1,2)
knots <- (1:B)/B*zeta_m
ZZ <- sapply(knots, FUN = function(x){
return(x^c(0:q))
})
ZZ <- t(ZZ)
dec_vec <- (-1)^c(0:q)
EX <- cbind(1, EX)
betahat_collect <- NULL
EX_model_id_collect <- NULL
para_index_collect <- NULL
poly_order_collect <- NULL
MSE_CV_value <- NULL
SSR <- NULL
for (j in 1:3){
for (perm_idx in 1:(dim(EX)[1])){
ZZ_sub <- ZZ[,as.logical(EX[perm_idx,])]
dec_vec_sub <- dec_vec[as.logical(EX[perm_idx,])]
est <- coefs_Z[,j+1]
beta_model <- as.vector(solve(t(ZZ_sub)%*%ZZ_sub) %*% t(ZZ_sub)%*% est)
betahat_poly <- sum(beta_model * dec_vec_sub)
## Get CV metric
MSE_CV_value <- c(MSE_CV_value, get_MSE_CV_step(B, ZZ_sub, est, nfold, CVstep, CVmfold) )
## Calculating SSR
SSR <- c(SSR, sum((est - ZZ_sub %*% t(t(beta_model)))^2) )
betahat_collect <- c(betahat_collect, betahat_poly)
EX_model_id_collect <- c(EX_model_id_collect, perm_idx)
para_index_collect <- c(para_index_collect, j)
poly_order_collect <- c(poly_order_collect, modelorder[perm_idx])
}
}
results <- data.frame(betahat = betahat_collect,
model_id = EX_model_id_collect,
para_id = para_index_collect,
order = poly_order_collect-1,
SSR = SSR,
MSE_CV_value = MSE_CV_value,
modeLavgM = rep(rowSums(EX)-1,3))
return(results)
}
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
ncores <- 50
nsample <- 1000
set.seed(2023)
seed_i <- sample(1000000,1000)
source("code/utility.R")
setwd("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX")
ncores <- 50
nsample <- 1000
set.seed(2023)
seed_i <- sample(1000000,1000)
source("code/utility.R")
result <- Sim_LavgM_CV_MEonly(SIM_id = seed_i[var1],
beta = betatrue,
Mis_mtr = matrix(c(0.7,0.3,0.3,0.7), nrow = 2, byrow = T),
sd_error = 2,
zeta_m = 5,
nfold = 20,
CVstep = 10,
CVmfold = 1)
result.
result
source("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX/code/Simulations/LM/shell_script_generator.R")
library(pscl)
library(tidyverse)
library(doParallel)
# library(survival)
# 1. Global Parameters  ----------------------------------------------------------
ncores <- 50
nsample <- 1000
set.seed(2023)
seed_i <- sample(1000000,1000)
source("code/utility.R")
setwd("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX")
matching_files <- list.files(path = "output/Simulation", pattern = "GIMEX-LavgM-Sim1.1.7.*\\.RData$", full.names = TRUE)
Simulation1.1.7_list <- NULL
for (file in matching_files) {
# Load the file
loaded_data <- load(file)
# The load function returns the name of the loaded object, which we can then use to access the object
data_name <- loaded_data[1]
# Store the loaded data frame in the data_list
Simulation1.1.7_list <- c(Simulation1.1.7_list, get(data_name))
# Cleanup: remove the loaded data frame from the environment
rm(list = data_name)
}
Simulation1.1.7 <- Simulation1.1.7_list
Sim1_results <- bind_rows(Simulation1.1.7, .id = "SimID")
results_all <- Sim1_results %>%
group_by(SimID) %>%
group_modify(~Summarize_Results(.x, B = 500, extrapolation = "all"))
source("code/utility.R")
results_all <- Sim1_results %>%
group_by(SimID) %>%
group_modify(~Summarize_Results(.x, B = 500, extrapolation = "all"))
results_all_plot <- results_all %>%
mutate(truth = factor(para_id, levels = 1:2, labels = c(betatrue)) ) %>%
mutate(truth = as.numeric(as.character(truth))) %>%
mutate(bias = abs(betahat  - truth)) %>%
mutate(variable_greek = factor(para_id, levels = 1:2, labels = c( expression(beta["con"]),expression(beta["dis"]) )))
betatrue <- c(1, -0.5, 0.5)
results_all_plot <- results_all %>%
mutate(truth = factor(para_id, levels = 1:3, labels = c(betatrue)) ) %>%
mutate(truth = as.numeric(as.character(truth))) %>%
mutate(bias = abs(betahat  - truth)) %>%
mutate(variable_greek = factor(para_id, levels = 1:3, labels = c( expression(beta["con"]),expression(beta["dis"]) )))
table(results_all$para_id
)
betatrue
results_all_plot <- results_all %>%
mutate(truth = factor(para_id, levels = 1:3, labels = c(betatrue)) )
results_all_plot <- results_all %>%
mutate(truth = factor(para_id, levels = 1:3, labels = c(betatrue)) ) %>%
mutate(truth = as.numeric(as.character(truth))) %>%
mutate(bias = abs(betahat  - truth)) %>%
mutate(variable_greek = factor(para_id, levels = 1:3, labels = c( expression(beta[0]),expression(beta["con"]),expression(beta["dis"]) )))
results_all_plot$extrapo <- factor(results_all$extrapo,
levels = c("linear", "quadratic", paste0("best subset of m=",1:6), "CV optimal order"),
labels = c("linear", "quadratic", paste0("best subset of m=",1:6), "CV optimal m") )
boxplot <- results_all_plot %>%
mutate(modelm = ifelse(extrapo == "CV optimal m", "optimal", modelm)) %>%
filter(!is.na(extrapo)) %>%
ggplot() +
geom_violin(aes(x=extrapo, y=bias, fill = modelm), trim=FALSE) +
geom_boxplot(aes(x=extrapo, y=bias), width=0.1, position= position_nudge(x=.15)) +
facet_grid(.~variable_greek,labeller = label_parsed, scales = "free") +
# coord_cartesian (ylim = c(0, 1.2))
scale_fill_manual(values=c( "#27BDBE", "#0096C9", "#B2D235",  "#FFD400", "#F7941D", "#C768A9", "#9E0918", "#5D6770")) +
theme_bw() +
theme(text=element_text(size=22), axis.text = element_text(size = 22),
axis.text.x = element_text(angle = 20, vjust = 1, hjust=1), panel.spacing = unit(1, "lines")) +
theme(strip.background =element_rect(fill="#3F4536",color="#3F4536"))+ # #535b44
theme(strip.text = element_text(colour = 'white')) +
theme(panel.border = element_rect(colour = "#3F4536"), legend.position = "none")  +
labs(x = "Extrapolation", y = "Bias", fill = "m" )
boxplot
source("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX/code/Simulations/ZIP/shell_script_generator.R")
source("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX/code/Simulations/CoxPH/shell_script_generator.R")
source("C:/Users/qzhang103/OneDrive - McGill University/Work/2022/GSIMEX/code/Simulations/CoxPH/shell_script_generator.R")
matching_files <- list.files(path = "output/Simulation", pattern = "GIMEX-coxPH-Sim1.1.6.*\\.RData$", full.names = TRUE)
Simulation1.1.6_list <- NULL
for (file in matching_files) {
# Load the file
loaded_data <- load(file)
# The load function returns the name of the loaded object, which we can then use to access the object
data_name <- loaded_data[1]
# Store the loaded data frame in the data_list
Simulation1.1.6_list <- c(Simulation1.1.6_list, get(data_name))
# Cleanup: remove the loaded data frame from the environment
rm(list = data_name)
}
Simulation1.1.6 <- Simulation1.1.6_list
# str(Simulation1)
Sim1_results <- bind_rows(Simulation1.1.6, .id = "SimID")
results_all <- Sim1_results %>%
group_by(SimID) %>%
group_modify(~Summarize_Results(.x, B = 5000, extrapolation = "all"))
